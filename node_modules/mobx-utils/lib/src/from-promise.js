"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var mobx_1 = require("mobx");
exports.PENDING = "pending";
exports.FULFILLED = "fulfilled";
exports.REJECTED = "rejected";
var PromiseBasedObservable = (function () {
    function PromiseBasedObservable(promise, initialValue) {
        if (initialValue === void 0) { initialValue = undefined; }
        var _this = this;
        this.promise = promise;
        this.value = undefined;
        this.state = exports.PENDING;
        this.value = initialValue;
        promise.then(mobx_1.action("observableFromPromise-resolve", function (value) {
            _this.value = value;
            _this.state = exports.FULFILLED;
        }), mobx_1.action("observableFromPromise-reject", function (reason) {
            _this.value = reason;
            _this.state = exports.REJECTED;
        }));
    }
    PromiseBasedObservable.prototype.case = function (handlers) {
        switch (this.state) {
            case exports.PENDING: return handlers.pending && handlers.pending();
            case exports.REJECTED: return handlers.rejected && handlers.rejected(this.value);
            case exports.FULFILLED: return handlers.fulfilled && handlers.fulfilled(this.value);
        }
    };
    return PromiseBasedObservable;
}());
__decorate([
    mobx_1.observable.ref
], PromiseBasedObservable.prototype, "value", void 0);
__decorate([
    mobx_1.observable.ref
], PromiseBasedObservable.prototype, "state", void 0);
/**
 * `fromPromise` takes a Promise and returns an object with 3 observable properties that track
 * the status of the promise. The returned object has the following observable properties:
 *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference
 *  - `state`: one of `"pending"`, `"fulfilled"` or `"rejected"`
 *  - `promise`: (not observable) the original promise object
 * and the following method:
 * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.
 *
 * @example
 * const fetchResult = fromPromise(fetch("http://someurl"))
 *
 * // combine with when..
 * when(
 *   () => fetchResult.state !== "pending"
 *   () => {
 *     console.log("Got ", fetchResult.value)
 *   }
 * )
 *
 * // or a mobx-react component..
 * const myComponent = observer(({ fetchResult }) => {
 *   switch(fetchResult.state) {
 *      case "pending": return <div>Loading...</div>
 *      case "rejected": return <div>Ooops... {fetchResult.value}</div>
 *      case "fulfilled": return <div>Gotcha: {fetchResult.value}</div>
 *   }
 * })
 *
 * // or using the case method instead of switch:
 *
 * const myComponent = observer(({ fetchResult }) =>
 *   fetchResult.case({
 *     pending:   () => <div>Loading...</div>
 *     rejected:  error => <div>Ooops.. {error}</div>
 *     fulfilled: value => <div>Gotcha: {value}</div>
 *   }))
 *
 * Note that the status strings are available as constants:
 * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`
 *
 * @param {IThenable<T>} promise The promise which will be observed
 * @param {T} [initialValue=undefined] Optional predefined initial value
 * @returns {IPromiseBasedObservable<T>}
 */
function fromPromise(promise, initialValue) {
    if (initialValue === void 0) { initialValue = undefined; }
    return new PromiseBasedObservable(promise, initialValue);
}
exports.fromPromise = fromPromise;
/**
  * Returns true if the provided value is a promise-based observable.
  * @param value any
  * @returns {boolean}
  */
function isPromiseBasedObservable(value) {
    return value instanceof PromiseBasedObservable;
}
exports.isPromiseBasedObservable = isPromiseBasedObservable;
